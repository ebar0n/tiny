package compilador;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import ast.*;	

action code {:
	private boolean modoDepuracion=false;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}

/*	public void printModoDepuracion(int lvl, String message){
		if(modoDepuracion) {
			while(lvl > 0) {
				System.out.print("");
				lvl--;
			}
			System.out.println(message); 	
	} */

	public void printModoDepuracion(String message){
		if(modoDepuracion)
			System.out.println("\t" + message); 	
	}
:}

parser code {: 

	public void syntax_error(Symbol s) {
		ComplexSymbol cs = (ComplexSymbol) s;
		System.err.println("########################");		
		System.err.println("Error de sintaxis");
		System.err.println("Linea:   " + cs.xleft.getLine());
		System.err.println("Columna: " + cs.xleft.getColumn());
		System.err.println("Simbolo: " + cs.getName());
		System.err.println("########################");
		System.exit(0);	
	}

	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception { 
	}
:}
/* Simbolos terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal FOR;
terminal BOOLEAN;
terminal INT;
terminal BEGIN;
terminal RETURN;
terminal VOID;
terminal NE;
terminal GE;
terminal LE;
terminal COMA;
terminal GT;
terminal LCLASP;
terminal RCLASP;
terminal AND;
terminal OR;
terminal TRUE;
terminal FALSE;

/* Simbolos No terminales */

non terminal program;
non terminal NodoBase unit;
non terminal NodoBase external_declaration;
non terminal NodoBase declarator_function;
non terminal NodoBase sentence_list;
non terminal NodoBase sentence;
non terminal NodoBase if_sentence;
non terminal NodoBase repeat_sentence;
non terminal NodoBase assign_sentence;
non terminal NodoBase read_sentence;
non terminal NodoBase write_sentence;
non terminal NodoBase expression;
non terminal NodoBase additive_expression;
non terminal NodoBase multiplicative_expression;
non terminal NodoBase factor;
non terminal NodoBase array_var_access;

non terminal NodoBase declare_variable;
non terminal NodoBase variable_list;
non terminal NodoBase for_sentence;
non terminal NodoBase return_sentence;
non terminal NodoBase declare_function;
non terminal NodoBase block_sentence;
non terminal NodoBase arguments_list_function;
non terminal NodoBase arguments_function;
non terminal NodoBase function_sentence;
non terminal NodoBase logical_expression;
non terminal tipoDato type_specifier;	

/* Precedencia de operadores */

precedence left AND, OR;
precedence left GE;
precedence left GT;
precedence left LE;
precedence left LT;
precedence left PLUS, MINUS;
precedence left TIMES, OVER;
precedence left LPAREN, RPAREN;

start with program;
/* REGLAS GRAMATICALES */
program		::= unit;

unit 		::= 
			external_declaration:ed block_sentence:d SEMI
				{: 
					printModoDepuracion("program");
					NodoBase hijoActual = ed;
					if(hijoActual != null){
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(d);
						ast=ed;
					}else{
						ast=d;
					}
				:}
			| block_sentence:d SEMI
				{: 
					printModoDepuracion("program");
					ast = d;
				:}
			;

external_declaration ::=
			external_declaration:exd declare_function:fd SEMI
				{: 
					printModoDepuracion("external_declaration -> declare_function SEMI");
					NodoBase hijoActual = exd;
					if(hijoActual !=null){
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(fd);
						RESULT=exd;
					}else{
						RESULT=fd;
					}
				:}
			| declare_function:fd SEMI
				{: 
	    			printModoDepuracion("external_declaration -> declare_function");
					RESULT=fd;				
				:}
			;

declare_variable	::= 
		type_specifier:type variable_list:v
			{: 
				printModoDepuracion("declare_variable -> type_specifier variable_list");
				RESULT = new NodoVariable(v, type);
			:}
		;

variable_list	::= 
		ID:variable COMA variable_list:v
			{: 
				printModoDepuracion("variable_list -> ID COMA variable_list"); 
				RESULT = new NodoVariable(new NodoIdentificador(variable), v);
			:}
		| ID:variable
			{: 
				printModoDepuracion("variable_list -> ID"); 
				RESULT = new NodoVariable(new NodoIdentificador(variable));
			:}
		| ID:variable LCLASP NUM:tam RCLASP COMA variable_list:v
			{:
				printModoDepuracion("variable_list -> ID LCLASP NUM RCLASP COMA variable_list"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), tam, v);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla variable_list -> ID LCLASP NUM RCLASP COMA variable_list");
				}
			:}
		| ID:variable LCLASP NUM:tam RCLASP
			{:
				printModoDepuracion("variable_list -> ID LCLASP NUM RCLASP"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), tam);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla variable_list -> ID LCLASP NUM RCLASP");
				}
			:}
		;
	
declare_function ::= 
		type_specifier:type ID:valor declarator_function:decl block_sentence:expression 
			{:
				printModoDepuracion("declare_function -> type_specifier ID declarator_function block_sentence");
				RESULT = new NodoFunction(type,valor,decl,expression);
			:}
		|	VOID:type ID:valor declarator_function:decl block_sentence:expression 
			{:
				printModoDepuracion("declare_function -> VOID declarator_function block_sentence");
				RESULT = new NodoFunction(tipoDato.VOID,valor,decl,expression);
			:}
		;

type_specifier	::=	
		INT
			{: 
				printModoDepuracion("type_specifier -> INT ");
				RESULT = tipoDato.INT;
			:}
		|	BOOLEAN
			{: 
				printModoDepuracion("type_specifier -> BOOLEAN");
				RESULT = tipoDato.BOOLEAN;
			:}		
		;

declarator_function ::=
	| LPAREN  RPAREN
	| LPAREN arguments_list_function:ptl RPAREN
		{:
			printModoDepuracion("declarator_function -> LPAREN arguments_list_function RPAREN");
			RESULT = ptl;
		:}
	;
block_sentence  ::= 
		BEGIN sentence_list:expression END 
			{:
				printModoDepuracion("block_sentence -> BEGIN sentence_list END");
				RESULT = new NodoBloque(expression);
			:} 
		;

arguments_list_function ::= 
		type_specifier:type ID:valor COMA arguments_list_function:arg
			{:
				printModoDepuracion("arguments_list_function -> type_specifier ID COMA arguments_list_function");
				RESULT = new NodoArgList(new NodoIdentificador(valor),type,arg);
			:}
		| type_specifier:type ID:valor
			{:
				printModoDepuracion("arguments_list_function -> type_specifier ID");
				RESULT = new NodoArgList(new NodoIdentificador(valor),type);
			:}
		;

sentence_list    ::=
		sentence_list:ini sentence:sent SEMI 
			{: 
				printModoDepuracion("sentence_list -> sentence_list sentence SEMI"); 
				NodoBase hijoActual = ini;
				if(hijoActual !=null){
					while(hijoActual.TieneHermano()){
						hijoActual = hijoActual.getHermanoDerecha();
					}
					hijoActual.setHermanoDerecha(sent);
					RESULT=ini;
				}else{
					RESULT=sent;
				}
			:}
	    | sentence:sent	SEMI
	    	{: 
	    		printModoDepuracion("sentence_list -> sentence SEMI");
				RESULT=sent;				
			:}
		;

sentence ::=
		if_sentence:is
			{:
				printModoDepuracion("sentence -> if_sentence"); 
				RESULT=is;
			:}
		| declare_variable:dv
			{: 
				printModoDepuracion("sentence -> declare_variable"); 
				RESULT=dv;
			:}	
		| declare_function:df
			{: 
				printModoDepuracion("sentence -> declare_function"); 
				RESULT=df;
			:}
		| block_sentence:bs
			{: 
				printModoDepuracion("sentence -> block_sentence"); 
				RESULT=bs;
			:}
        | repeat_sentence:rs
        	{:
        		printModoDepuracion("sentence -> repeat_sentence"); 
				RESULT=rs;
			:}
		| assign_sentence:as
			{: 
				printModoDepuracion("sentence -> assign_sentence"); 
				RESULT=as;
			:}
        | read_sentence:rs
        	{: 
        		printModoDepuracion("sentence -> read_sentence");  
				RESULT=rs;
			:}
        | write_sentence:ws
        	{: 
        		printModoDepuracion("sentence -> write_sentence");
				RESULT=ws;
			:}
		| for_sentence:fs 
			{:
				printModoDepuracion("sentence -> for_sentence"); 
				RESULT=fs;
			:}
		| return_sentence:rs
			{: 
				printModoDepuracion("sentence -> return_sentence"); 
				RESULT=rs;
			:} 
		| function_sentence:fs
			{: 
				printModoDepuracion("sentence -> function_sentence"); 
				RESULT=fs;
			:}
        | error
        	{: 
        		System.out.println("Ocurrio error en cup regla sentence");
        		System.exit(1);
			:}
    	;

if_sentence ::= 
	IF logical_expression:le THEN sentence_list:sl END 
		{: 
			printModoDepuracion("if_sentence -> IF logical_expression THEN sentence_list END"); 
			RESULT = new NodoIf(le,sl);
		:}
	| IF logical_expression:le THEN sentence_list:slthen ELSE sentence_list:slelse END
		{: 
			printModoDepuracion("if_sentence -> IF logical_expression THEN sentence_list ELSE sentence_list END"); 
			RESULT = new NodoIf(le,slthen,slelse);
		:}
	;

repeat_sentence ::= 
		REPEAT sentence_list:sl UNTIL expression:ex
			{: 
				printModoDepuracion("repeat_sentence -> REPEAT sentence_list UNTIL expression");
				RESULT = new NodoRepeat(sl,ex);
			:}
		;

assign_sentence ::= 
		ID:variable ASSIGN logical_expression:ex	
			{: 
				printModoDepuracion("assign_sentence -> ID ASSIGN");
				if(variable!=null)
					RESULT = new NodoAsignacion(new NodoIdentificador(variable),ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_sentence -> ID");
				}
			:}
		| array_var_access:vesc	ASSIGN logical_expression:ex
			{: 
				printModoDepuracion("assign_sentence -> array_var_access");
				if(vesc!=null && ex!=null)
					RESULT = new NodoAsignacion((NodoArray)vesc,ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_sentence -> array_var_access");
				}
			:}
		;

read_sentence   ::=
		READ ID:variable
			{: 
				printModoDepuracion("read_sentence -> ID"); 
				if(variable!=null)
					RESULT = new NodoLeer(new NodoIdentificador(variable));
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_sentence -> ID");
				}
			:}
		| READ array_var_access:variable
			{: 
				printModoDepuracion("read_sentence -> array_var_access"); 
				if(variable!=null)
					RESULT = new NodoLeer(variable);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_sentence -> array_var_access");
				}
			:}
		;

write_sentence  ::=
		WRITE logical_expression:ex
			{: 
				printModoDepuracion("write_sentence -> expression"); 
				RESULT= new NodoEscribir(ex);
			:}
		;

for_sentence 	::=
		FOR LPAREN assign_sentence:ini SEMI logical_expression:cond SEMI assign_sentence:inc RPAREN sentence_list:sent END 
			{: 
				printModoDepuracion("for_sentence");
				RESULT = new NodoFor(ini,cond,inc,sent);
			:}
		;

return_sentence ::= 
		RETURN logical_expression:fact
			{: 
				printModoDepuracion("return_sentence -> logical_expression");
				RESULT = new NodoReturn(fact);
			:}
		| RETURN 
			{: 
				printModoDepuracion("return_sentence -> empty");
				RESULT = new NodoReturn();
			:};

function_sentence ::= 
		ID:valor LPAREN arguments_function:variables RPAREN 
			{:
				printModoDepuracion("function_sentence -> arguments_function");
				RESULT = new NodoCallFunction(new NodoIdentificador(valor),variables);
			:}
		| ID:valor LPAREN RPAREN
			{:
				printModoDepuracion("function_sentence -> not arguments_function");
				RESULT = new NodoCallFunction(new NodoIdentificador(valor));
			:}
		;

logical_expression ::= 
		expression:exI AND logical_expression:exD
			{: 
				printModoDepuracion("logical_expression -> AND logical_expression");
				RESULT = new NodoLogico(exI,tipoOp.and,exD);			
			:}

		| expression:exI OR logical_expression:exD
			{:
				printModoDepuracion("logical_expression -> OR logical_expression");
				RESULT = new NodoLogico(exI,tipoOp.or,exD);	
			:}
		| expression:exl
			{: 
				printModoDepuracion("logical_expression -> expression");
				RESULT = new NodoLogico(exl);						
			:}
		;

expression  ::=
		additive_expression:exI GE additive_expression:exD
			{: 
				printModoDepuracion("expression -> GE");
				RESULT = new NodoOperacion(exI,tipoOp.mayori,exD);
			:} 
		| additive_expression:exI GT additive_expression:exD
			{: 
				printModoDepuracion("expression -> GT");
				RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
			:}
		 
		| additive_expression:exI LE additive_expression:exD
			{: 
				printModoDepuracion("expression -> LE");
				RESULT = new NodoOperacion(exI,tipoOp.menori,exD);
			:}
		| additive_expression:exI LT additive_expression:exD	
			{: 
				printModoDepuracion("expression -> LT");
				RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
			:}
		| additive_expression:exI EQ additive_expression:exD
			{: 
				printModoDepuracion("expression -> EQ");
				RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
			:} 
		| additive_expression:exI NE additive_expression:exD
			{: 
				printModoDepuracion("expression -> NE");
				RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
			:}
		| additive_expression:ex
			{: 
				printModoDepuracion("expression -> additive_expression");
				RESULT = ex;
			:}
		;

additive_expression  ::=
		additive_expression:exI PLUS multiplicative_expression:exD
			{: 
				printModoDepuracion("additive_expression -> PLUS");
				RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
			:}
		| additive_expression:exI MINUS multiplicative_expression:exD
			{: 
				printModoDepuracion("additive_expression -> MINUS");
				RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
			:}
		| multiplicative_expression:ex
			{:
				printModoDepuracion("additive_expression -> multiplicative_expression");
				RESULT=ex;
			:}
		;

multiplicative_expression        ::= 
		multiplicative_expression:exI TIMES factor:exD
			{: 
				printModoDepuracion("multiplicative_expression -> TIMES");
				RESULT = new NodoOperacion(exI,tipoOp.por,exD);
			:}
		| multiplicative_expression:exI OVER factor:exD
			{: 
				printModoDepuracion("multiplicative_expression -> OVER");
				RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
			:}
		| factor:ex
			{: 
				printModoDepuracion("multiplicative_expression -> factor");
				RESULT=ex;
			:}
		;

factor      ::= 
		LPAREN logical_expression:ex RPAREN	
			{: 
				printModoDepuracion("factor -> LPAREN logical_expression RPAREN");
				RESULT = ex;
			:}
		| NUM:valor
			{: 
				printModoDepuracion("factor -> NUM");
				if(valor!=null){
					RESULT= new NodoValor(valor);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM");
				}
			:}
		| MINUS NUM:valor 
        	{: 
				printModoDepuracion("factor -> MINUS NUM");
				if(valor!=null){
					RESULT= new NodoValor(valor*-1);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM NEGATIVO");
				}
			:}
		| ID:variable
			{: 
				printModoDepuracion("factor -> ID");
				if(variable!=null){
					//System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
					System.out.println(variable);
					RESULT= new NodoIdentificador(variable);		
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> ID");
				}
			:}
		| TRUE   
			{: 
				printModoDepuracion("factor -> TRUE");
				RESULT= new NodoValor(true);					
			:}
		| FALSE
			{: 
				printModoDepuracion("factor -> FALSE");
				RESULT= new NodoValor(false);					
			:}
		| array_var_access:vesc	
			{: 
				printModoDepuracion("expression -> array_var_access");
				RESULT=vesc;
			:}
		| function_sentence:vesc	
			{: 
				printModoDepuracion("expression -> function_sentence");
				RESULT=vesc;
			:}
		| error
			{: 
				System.out.println("Ocurrio error en cup regla factor");
				RESULT=null;
			:}
		;

array_var_access	::= 
		ID:variable LCLASP additive_expression:pos RCLASP
			{:
				printModoDepuracion("array_var_access");
				if(variable!=null && pos!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), pos);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla array_var_access");
				}
			:}	
		;


arguments_function ::= 
		logical_expression:le COMA arguments_function:af
			{:
				printModoDepuracion("arguments_function -> logical_expression COMA arguments_function");
				RESULT = new NodoParamFunction(le,af);
			:}
		| logical_expression:le
			{:
				printModoDepuracion("arguments_function -> logical_expression");
				RESULT = new NodoParamFunction(le);
			:}
		;
