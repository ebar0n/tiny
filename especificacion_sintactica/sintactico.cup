package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=false;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}

	public void printModoDepuracion(String message){
		if(modoDepuracion) {
			System.out.println("\t" + message); 	
		}
	}
:}

parser code {: 

	public void syntax_error(Symbol s) {
		System.err.println("########################");		
		System.err.println("Error de sintaxis");
		System.err.println("Linea " + s.left);
		System.err.println("Columna " + s.right);
		System.err.println("Sym " + s.sym);
		System.err.println("########################");
		System.exit(0);	
	}

	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception { 
	}
:}
/* Simbolos terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal FOR;
terminal BOOLEAN;
terminal INT;
terminal BEGIN;
terminal RETURN;
terminal VOID;
terminal NE;
terminal GE;
terminal LE;
terminal COMA;
terminal GT;
terminal LCLASP;
terminal RCLASP;
terminal AND;
terminal OR;
terminal TRUE;
terminal FALSE;

/* Simbolos No terminales */

non terminal program;
non terminal NodoBase unit;
non terminal NodoBase external_declaration;
non terminal NodoBase declarator_function;
non terminal NodoBase sentence_list;
non terminal NodoBase sentence;
non terminal NodoBase if_sentence;
non terminal NodoBase repeat_sentence;
non terminal NodoBase assign_sentence;
non terminal NodoBase read_sentence;
non terminal NodoBase write_sentence;
non terminal NodoBase expression;
non terminal NodoBase additive_expression;
non terminal NodoBase multiplicative_expression;
non terminal NodoBase factor;
non terminal NodoBase array_var_access;

non terminal NodoBase declare_variable;
non terminal NodoBase variable_list;
non terminal NodoBase for_sentence;
non terminal NodoBase return_sentence;
non terminal NodoBase declare_function;
non terminal NodoBase block_sentence;
non terminal NodoBase arguments_list_function;
non terminal NodoBase arguments_function;
non terminal NodoBase function_sentence;
non terminal NodoBase logical_expression;
non terminal tipoDato type_specifier;	

/* Precedencia de operadores */

precedence left AND, OR;
precedence left GE;
precedence left GT;
precedence left LE;
precedence left LT;
precedence left PLUS, MINUS;
precedence left TIMES, OVER;
precedence left LPAREN, RPAREN;

start with program;
/* REGLAS GRAMATICALES */
program		::= unit;

unit 		::= 
			external_declaration:ed block_sentence:d SEMI
				{: 
					printModoDepuracion("regla program");
					NodoBase hijoActual = ed;
					if(hijoActual !=null){
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(d);
						ast=ed;
					}else{
						ast=d;
					}
				:}
			| block_sentence:d SEMI
				{: 
					printModoDepuracion("regla program");
					ast = d;
				:}
			;

external_declaration ::=
			external_declaration:exd declare_function:fd SEMI
				{: 
					printModoDepuracion("\t regla external_declaration -> declare_function SEMI");
					NodoBase hijoActual = exd;
					if(hijoActual !=null){
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(fd);
						RESULT=exd;
					}else{
						RESULT=fd;
					}
				:}
			| declare_function:fd SEMI
				{: 
	    			printModoDepuracion("\t regla external_declaration -> declare_function");
					RESULT=fd;				
				:}
			;

declare_variable	::= 
		type_specifier:type variable_list:v
			{: 
				printModoDepuracion("\t regla declare_variable");
				RESULT = new NodoVariable(v,type);
			:}
		;

variable_list	::= 
		ID:variable COMA variable_list:v
			{: 
				printModoDepuracion("\t\t regla variable_list -> ID COMA"); 
				RESULT = new NodoVariable(new NodoIdentificador(variable), v);
			:}
		| ID:variable
			{: 
				printModoDepuracion("\t\t regla variable_list -> ID"); 
				RESULT = new NodoVariable(new NodoIdentificador(variable));
			:}
		| ID:variable LCLASP NUM:tam RCLASP COMA variable_list:v
			{:
				printModoDepuracion("\t\t regla variable_list -> array_declare COMA"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), tam, v);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla variable_list -> array_declare COMA");
				}
			:}
		| ID:variable LCLASP NUM:tam RCLASP
			{:
				printModoDepuracion("\t\t regla variable_list -> array_declare"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), tam);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla variable_list -> array_declare COMA");
				}
			:}
		;
	
declare_function ::= 
		type_specifier:type ID:valor declarator_function:decl block_sentence:expression 
			{:
				printModoDepuracion("\t regla declare_function -> VOID arguments_list_function");
				RESULT = new NodoFunction(type,valor,decl,expression);
			:}
		|	VOID:type ID:valor declarator_function:decl block_sentence:expression 
			{:
				printModoDepuracion("\t regla declare_function -> VOID arguments_list_function");
				RESULT = new NodoFunction(tipoDato.VOID,valor,decl,expression);
			:}
		;

type_specifier	::=	
		INT
			{: 
				printModoDepuracion("\t regla INT ");
				RESULT = tipoDato.INT;
			:}
		|	BOOLEAN
			{: 
				printModoDepuracion("\t regla boolean de tipo");
				RESULT = tipoDato.BOOLEAN;
			:}		
		;

declarator_function ::=
	| LPAREN  RPAREN
	| LPAREN arguments_list_function:ptl RPAREN
		{:
			printModoDepuracion("\t regla declarator_function -> Lista arguments_list_function");
			RESULT = new NodoArgList(ptl);
		:}
	;
block_sentence  ::= 
		BEGIN sentence_list:expression END 
			{:
				printModoDepuracion("regla return_sentence -> block_sentence");
				RESULT = new NodoBloque(expression);
			:} 
		;

arguments_list_function ::= 
		type_specifier:tipo ID:valor COMA arguments_list_function:arg
			{:
				printModoDepuracion("\t\t regla arguments_list_function -> INT ID COMA");
				RESULT = new NodoArgList(valor,tipo,arg);
			:}
		| type_specifier:tipo ID:valor
			{:
				printModoDepuracion("\t\t regla arguments_list_function -> INT ID");
				RESULT = new NodoArgList(valor,tipo);
			:}
		;

sentence_list    ::=
		sentence_list:ini sentence:sent SEMI 
			{: 
				printModoDepuracion("\t regla sentence_list -> sentence_list sentence"); 
				NodoBase hijoActual = ini;
				if(hijoActual !=null){
					while(hijoActual.TieneHermano()){
						hijoActual = hijoActual.getHermanoDerecha();
					}
					hijoActual.setHermanoDerecha(sent);
					RESULT=ini;
				}else{
					RESULT=sent;
				}
			:}
	    | sentence:sent	SEMI
	    	{: 
	    		printModoDepuracion("\t regla sentence_list -> sentence");
				RESULT=sent;				
			:}
		;

sentence ::=
		if_sentence:sif
			{: 
				printModoDepuracion("\t\t regla sentence -> if_sentence"); 
				RESULT=sif;
			:}
		| declare_variable:dclvar
			{: 
				printModoDepuracion("\t\t regla sentence -> declare_variable"); 
				RESULT=dclvar;
			:}	
		| declare_function:declafunc
			{: 
				printModoDepuracion("\t\t regla sentence -> declare_function"); 
				RESULT=declafunc;
			:}
		| block_sentence:declablo
			{: 
				printModoDepuracion("\t\t regla sentence -> block_sentence"); 
				RESULT=declablo;
			:}
        | repeat_sentence:srep
        	{:
        		printModoDepuracion("\t\t regla sentence -> repeat_sentence"); 
				RESULT=srep;
			:}
		| assign_sentence:sasi
			{: 
				printModoDepuracion("\t\t regla sentence -> assign_sentence"); 
				RESULT=sasi;
			:}
        | read_sentence:slec
        	{: 
        		printModoDepuracion("\t\t regla sentence -> read_sentence");  
				RESULT=slec;
			:}
        | write_sentence:sesc
        	{: 
        		printModoDepuracion("\t\t regla sentence -> write_sentence");
				RESULT=sesc;
			:}
		| for_sentence:sfor 
			{:
				printModoDepuracion("\t\t regla sentence -> for_sentence"); 
				RESULT=sfor;
			:}
		| return_sentence:sretr
			{: 
				printModoDepuracion("\t\t regla sentence -> return_sentence"); 
				RESULT=sretr;
			:} 
		| function_sentence:callfunc_procedure
			{: 
				printModoDepuracion("\t\t regla sentence -> function_sentence by procedure"); 
				RESULT=callfunc_procedure;
			:}
        | error
        	{: 
        		System.out.println("Ocurrio error en cup regla sentence");
        		System.exit(1);
			:}
    	;

if_sentence ::= 
	IF logical_expression:ex THEN sentence_list:pthen END 
		{: 
			printModoDepuracion("\t\t\t regla if_sentence -> logical_expression"); 
			RESULT = new NodoIf(ex,pthen);
		:}
	| IF logical_expression:ex THEN sentence_list:pthen ELSE sentence_list:pelse END
		{: 
			printModoDepuracion("\t\t\t regla if_sentence -> logical_expression else"); 
			RESULT = new NodoIf(ex,pthen,pelse);
		:}
	;

repeat_sentence ::= 
		REPEAT sentence_list:cuerpo UNTIL expression:prueba	
			{: 
				printModoDepuracion("\t\t\t regla repeat_sentence");
				RESULT = new NodoRepeat(cuerpo,prueba);
			:}
		;

assign_sentence ::= 
		ID:variable ASSIGN expression:ex	
			{: 
				printModoDepuracion("\t\t\t regla assign_sentence -> ID");
				if(variable!=null)
					RESULT = new NodoAsignacion(new NodoIdentificador(variable),ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_sentence -> ID");
				}
			:}
		| array_var_access:vesc	ASSIGN expression:ex
			{: 
				printModoDepuracion("\t\t\t regla assign_sentence -> array_var_access");
				if(vesc!=null && ex!=null)
					RESULT = new NodoAsignacion(vesc,ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_sentence -> array_var_access");
				}
			:}
		;

read_sentence   ::=
		READ ID:variable
			{: 
				printModoDepuracion("\t\t\t  regla read_sentence -> ID"); 
				if(variable!=null)
					RESULT = new NodoLeer(new NodoIdentificador(variable));
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_sentence -> ID");
				}
			:}
		| READ array_var_access:variable
			{: 
				printModoDepuracion("\t\t\t  regla read_sentence -> array_var_access"); 
				if(variable!=null)
					RESULT = new NodoLeer(variable);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_sentence -> array_var_access");
				}
			:}
		;

write_sentence  ::=
		WRITE logical_expression:ex
			{: 
				printModoDepuracion("\t\t\t  regla write_sentence -> expression"); 
				RESULT= new NodoEscribir(ex);
			:}
		;

for_sentence 	::=
		FOR LPAREN assign_sentence:ini SEMI logical_expression:cond SEMI assign_sentence:inc RPAREN sentence_list:sent END 
			{: 
				printModoDepuracion("\t  regla for_sentence");
				RESULT = new NodoFor(ini,cond,inc,sent);
			:}
		;

return_sentence ::= 
		RETURN factor:fact
			{: 
				printModoDepuracion("\t\t  regla return_sentence -> factor");
				RESULT = new NodoReturn(fact);
			:}
		| RETURN 
			{: 
				printModoDepuracion("\t\t  regla return_sentence -> empty");
				RESULT = new NodoReturn();
			:};

function_sentence ::= 
		ID:valor LPAREN arguments_function:variables RPAREN 
			{:
				printModoDepuracion("\t\t regla function_sentence -> arguments_function");
				RESULT = new NodoCallFunction(valor,variables);
			:}
		| ID:valor LPAREN RPAREN
			{:
				printModoDepuracion("\t\t regla function_sentence -> not arguments_function");
				RESULT = new NodoCallFunction(valor);
			:}
		;

logical_expression ::= 
		expression:exI AND logical_expression:exD
			{: 
				printModoDepuracion("\t\t\t  regla logical_expression -> AND logical_expression");
				RESULT = new NodoLogico(exI,tipoOp.and,exD);			
			:}

		| expression:exI OR logical_expression:exD
			{:
				printModoDepuracion("\t\t\t  regla logical_expression -> OR logical_expression");
				RESULT = new NodoLogico(exI,tipoOp.or,exD);	
			:}
		| expression:exl
			{: 
				printModoDepuracion("\t\t\t  regla logical_expression -> expression");
				RESULT = new NodoLogico(exl);						
			:}
		;

expression  ::=
		additive_expression:exI GE additive_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> GE");
				RESULT = new NodoOperacion(exI,tipoOp.mayori,exD);
			:} 
		| additive_expression:exI GT additive_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> GT");
				RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
			:}
		 
		| additive_expression:exI LE additive_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> LE");
				RESULT = new NodoOperacion(exI,tipoOp.menori,exD);
			:}
		| additive_expression:exI LT additive_expression:exD	
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> LT");
				RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
			:}
		| additive_expression:exI EQ additive_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> EQ");
				RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
			:} 
		| additive_expression:exI NE additive_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> NE");
				RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
			:}
		| additive_expression:ex
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> additive_expression");
				RESULT = ex;
			:}
		;

additive_expression  ::=
		additive_expression:exI PLUS multiplicative_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t\t  regla additive_expression -> PLUS");
				RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
			:}
		| additive_expression:exI MINUS multiplicative_expression:exD
			{: 
				printModoDepuracion("\t\t\t\t\t  regla additive_expression -> MINUS");
				RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
			:}
		| multiplicative_expression:ex
			{:
				printModoDepuracion("\t\t\t\t\t  regla additive_expression -> multiplicative_expression");
				RESULT=ex;
			:}
		;

multiplicative_expression        ::= 
		multiplicative_expression:exI TIMES factor:exD
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla multiplicative_expression -> TIMES");
				RESULT = new NodoOperacion(exI,tipoOp.por,exD);
			:}
		| multiplicative_expression:exI OVER factor:exD
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla multiplicative_expression -> OVER");
				RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
			:}
		| factor:ex
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor");
				RESULT=ex;
			:}
		;

factor      ::= 
		LPAREN logical_expression:ex RPAREN	
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> PAREN");
				RESULT = ex;
			:}
		| NUM:valor
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> NUM");
				if(valor!=null){
					RESULT= new NodoValor(valor);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM");
				}
			:}
		| MINUS NUM:valor 
        	{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> NUM NEGATIVO");
				if(valor!=null){
					RESULT= new NodoValor(valor*-1);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM NEGATIVO");
				}
			:}
		| ID:variable
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> ID");
				if(variable!=null){
					//System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
					RESULT= new NodoIdentificador(variable);		
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> ID");
				}
			:}
		| TRUE   
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> TRUE");
				RESULT= new NodoValor(true);					
			:}
		| FALSE
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> TRUE");
				RESULT= new NodoValor(false);					
			:}
		| array_var_access:vesc	
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> array_var_access");
				RESULT=vesc;
			:}
		| function_sentence:vesc	
			{: 
				printModoDepuracion("\t\t\t\t  regla expression -> function_sentence");
				RESULT=vesc;
			:}
		| error
			{: 
				System.out.println("Ocurrio error en cup regla factor");
				RESULT=null;
			:}
		;

array_var_access	::= 
		ID:variable LCLASP additive_expression:pos RCLASP
			{:
				printModoDepuracion("\t\t\t\t  regla array_var_access");
				if(variable!=null && pos!=null){
					RESULT= new NodoArray(new NodoIdentificador(variable), pos);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla array_var_access");
				}
			:}	
		;


arguments_function ::= 
		logical_expression:parametro COMA arguments_function:arg
			{:
				printModoDepuracion("\t\t regla arguments_function -> parametro COMA");
				RESULT = new NodoParamFunction(parametro,arg);
			:}
		| logical_expression:parametro
			{:
				printModoDepuracion("\t\t regla arguments_function -> additive_expression");
				RESULT = new NodoParamFunction(parametro);
			:}
		;
