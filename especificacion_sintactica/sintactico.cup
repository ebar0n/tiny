package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal FOR;
terminal BOOLEAN;
terminal INT;
terminal BEGIN;
terminal RETURN;
terminal VOID;
terminal NE;
terminal GE;
terminal LE;
terminal COMA;
terminal GT;
terminal LCLASP;
terminal RCLASP;
terminal AND;
terminal OR;
terminal TRUE;
terminal FALSE;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase array_var_access;

non terminal NodoBase decl_var;
non terminal NodoBase var_list;
non terminal NodoBase eq_stmt;
non terminal NodoBase for_stmt;
non terminal NodoBase return_stmt;
non terminal NodoBase funcion_stmt;
non terminal NodoBase bloque_stmt;
non terminal NodoBase decl_fun;
non terminal NodoBase param_funcion;
non terminal NodoBase call_funcion;

/* Precedencia de operadores */
precedence left OR;
precedence left AND;
precedence left GE;
precedence left GT;
precedence left LE;
precedence left LT;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left LPAREN;
precedence left RPAREN;



/* REGLAS GRAMATICALES */
program     ::= stmt_seq:s	{: if(modoDepuracion) System.out.println("\t regla 1"); 
					ast = s;
					:}
		;
		
decl_var	::= INT var_list:v
				{: if(modoDepuracion) System.out.println("\t regla INT var_list");
					RESULT = new NodoVariable(v,tipoDato.INT);
				:}
			| BOOLEAN var_list:v
				{: if(modoDepuracion) System.out.println("\t regla BOOLEAN var_list");
					RESULT = new NodoVariable(v,tipoDato.BOOLEAN);
				:}
			;
			
var_list	::= ID:variable COMA var_list:v
				{: if(modoDepuracion) System.out.println("\t regla ID COMA var_list"); 
					RESULT = new NodoVariable(variable.toString(), v);
				:}
			| ID:variable
				{: if(modoDepuracion) System.out.println("\t regla ID"); 
					RESULT = new NodoVariable(variable.toString());
				:}
			| ID:variable LCLASP NUM:tam RCLASP COMA var_list:v
				{:
					if(modoDepuracion) System.out.println("\t regla array_declare"); 
						System.out.println("Declarando variable tipo vector + var_list ");
					if(variable!=null && tam!=null){
						RESULT= new NodoArray(variable.toString(), tam, v);					
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # array_declare");
					}
				:}
			| ID:variable LCLASP NUM:tam RCLASP
				{:
					if(modoDepuracion) System.out.println("\t regla array_declare"); 
						System.out.println("Declarando variable tipo vector");
					if(variable!=null && tam!=null){
						RESULT= new NodoArray(variable.toString(), tam);					
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # array_declare");
					}
				:}
			;
			
stmt_seq    ::=stmt_seq:ini stmt:sent SEMI {: if(modoDepuracion) System.out.println("\t regla 2a"); 
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							hijoActual.setHermanoDerecha(sent);
							RESULT=ini;
						}else{
							RESULT=sent;
						}
						:}
            | stmt:sent	SEMI{: if(modoDepuracion) System.out.println("\t regla 2b"); 
				RESULT=sent;				
				:}
			;

stmt        ::= if_stmt:sif	{: if(modoDepuracion) System.out.println("\t regla 3a"); 
					RESULT=sif;
					:}
			| decl_var:dclvar
				{: if(modoDepuracion) System.out.println("\t regla decl_var"); 
					RESULT=dclvar;
				:}	
			| funcion_stmt
			| bloque_stmt
            | repeat_stmt:srep	{: if(modoDepuracion) System.out.println("\t regla 3b"); 
						RESULT=srep;
						:}
            | assign_stmt:sasi	{: if(modoDepuracion) System.out.println("\t regla 3c"); 
						RESULT=sasi;
						:}
            | read_stmt:slec	{: if(modoDepuracion) System.out.println("\t regla 3d"); 
					RESULT=slec;
					:}
            | write_stmt:sesc	{: if(modoDepuracion) System.out.println("\t regla 3e"); 
					RESULT=sesc;
					:}
			| for_stmt:sfor {: System.out.println("\t regla for"); 
					RESULT=sfor;
					:}
			| return_stmt:sretr {: System.out.println("\t regla return"); 
					RESULT=sretr;
					:} 
			| call_funcion:callfunc
				{: if(modoDepuracion) System.out.println("\t regla call_func"); 
					RESULT=callfunc;
				:}
            | error	{: if(modoDepuracion) System.out.println("\t regla 3g"); 
				System.out.println("Ocurrio error en cup # 0004");
				RESULT=null;
				:}
            ;

if_stmt     ::= IF exp:ex THEN stmt_seq:pthen END {: if(modoDepuracion) System.out.println("\t regla 4a"); 
		RESULT = new NodoIf(ex,pthen);
		:}
		| IF exp:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END	{: if(modoDepuracion) System.out.println("\t regla 4b"); 
		RESULT = new NodoIf(ex,pthen,pelse);
		:}
		;

repeat_stmt ::= REPEAT stmt_seq:cuerpo UNTIL exp:prueba	{: if(modoDepuracion) System.out.println("\t regla 5"); 
							RESULT = new NodoRepeat(cuerpo,prueba);
							:}
		;

assign_stmt ::= ID:variable 	{: if(modoDepuracion) System.out.println("\t regla 6 parte del medio"); 
				/*lineanum=1000; //Pasar/Obtener la linea correcta por el Simbolo
				String nombre = variable.getName();*/
				:}
			ASSIGN exp:ex	{: if(modoDepuracion) System.out.println("\t regla 6 parte final");
					if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0001");
					}
					:}
			|	array_var_access:vesc	
				{: if(modoDepuracion) System.out.println("\t regla vector asing"); 
					RESULT=vesc;
				:}
				ASSIGN exp:ex
				{: 
					if(modoDepuracion) System.out.println("\t regla 6 parte final");
					if(vesc!=null)
						RESULT = new NodoAsignacion(vesc,ex);
					else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0001");
					}
				:}
		;

read_stmt   ::= READ ID:variable	{: if(modoDepuracion) System.out.println("\t regla 7"); 
					System.out.println("Leyendo Variable");
					if(variable!=null)
					RESULT = new NodoLeer(variable.toString());
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0002");
					}
					:}
		;

write_stmt  ::= WRITE exp:ex	{: if(modoDepuracion) System.out.println("\t regla 8"); 
					RESULT= new NodoEscribir(ex);
					:}
		;

exp    ::=simple_exp:exI GE simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9e"); 
								RESULT = new NodoOperacion(exI,tipoOp.mayori,exD);
								:} 
		|simple_exp:exI GT simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9g"); 
								RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
								:}
		 
		| simple_exp:exI LE simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9f"); 
								RESULT = new NodoOperacion(exI,tipoOp.menori,exD);
								:}
		| 
		 simple_exp:exI LT simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9a"); 
								RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
								:}
		|simple_exp:exI EQ simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9b"); 
							RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
							:} 
		
		| simple_exp:exI NE simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla 9h"); 
								RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
								:}

		| simple_exp:exI AND simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla AND"); 
								RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
								:}

		| simple_exp:exI OR simple_exp:exD	{: if(modoDepuracion) System.out.println("\t regla OR"); 
								RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
								:}

		| simple_exp:ex	{: if(modoDepuracion) System.out.println("\t regla 9i"); 
						RESULT = ex;
					:}
		| array_var_access:vesc	{: if(modoDepuracion) System.out.println("\t regla vector"); 
					RESULT=vesc;
					:}
		;

simple_exp  ::= simple_exp:exI PLUS term:exD	{: if(modoDepuracion) System.out.println("\t regla 10a"); 
							RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
							:}
		| simple_exp:exI MINUS term:exD	{: if(modoDepuracion) System.out.println("\t regla 10b"); 
							RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
							:}
		| term:ex	{: if(modoDepuracion) System.out.println("\t regla 10c"); 
				RESULT=ex;
				:}
		;

term        ::= term:exI TIMES factor:exD	{: if(modoDepuracion) System.out.println("\t regla 11a"); 
							RESULT = new NodoOperacion(exI,tipoOp.por,exD);
							:}
		| term:exI OVER factor:exD	{: if(modoDepuracion) System.out.println("\t regla 11b"); 
						RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
						:}
		| factor:ex	{: if(modoDepuracion) System.out.println("\t regla 11c"); 
					RESULT=ex;
					:}
		;

factor      ::= LPAREN exp:ex RPAREN	{: if(modoDepuracion) System.out.println("\t regla 12a"); 
							RESULT = ex;
							:}
		| NUM:valor	{: if(modoDepuracion) System.out.println("\t regla 12b"); 
					System.out.println("Devolvi nodo numero entero");
					if(valor!=null){
						RESULT= new NodoValor(valor);					
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| ID:variable	{: if(modoDepuracion) System.out.println("\t regla 12c"); 
					if(variable!=null){
						System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
						RESULT= new NodoIdentificador(variable.toString());		
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| TRUE      {: if(modoDepuracion) System.out.println("\t regla 12d"); 
						RESULT= new NodoValor(true);					
					:}
		| FALSE		{: if(modoDepuracion) System.out.println("\t regla 12e"); 
						RESULT= new NodoValor(false);					
					:}
		| error	{: if(modoDepuracion) System.out.println("\t regla 12d"); 
				System.out.println("Ocurrio error en cup # 0003");
				RESULT=null;
				:}
		;

array_var_access	::= ID:variable LCLASP simple_exp:pos RCLASP
				{:
					if(modoDepuracion) System.out.println("\t regla array_var_access"); 
						System.out.println("Accediendo a variable tipo vector");
					if(variable!=null && pos!=null){
						RESULT= new NodoArray(variable.toString(), pos);					
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # array_var_access");
					}
				:}	
		;

eq_stmt ::= ID:variable EQ exp:ex	{: if(modoDepuracion) System.out.println("\t regla 13");
					if(variable!=null)
						RESULT = new NodoAsignacion(variable.toString(),ex);
					else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 00013");
					}
					:}
		;

for_stmt ::= FOR LPAREN eq_stmt:ini SEMI exp:cond SEMI eq_stmt:inc RPAREN stmt_seq:sent END {: if(modoDepuracion) System.out.println("\t regla for");
				RESULT = new NodoFor(ini,cond,inc,sent);
			:}
		;

return_stmt ::= RETURN factor:fact {: if(modoDepuracion) System.out.println("\t regla RETURN a");
						RESULT = new NodoReturn(fact);
					:}
				| RETURN  {: if(modoDepuracion) System.out.println("\t regla RETURN b");
						RESULT = new NodoReturn();
					:};

bloque_stmt  ::= BEGIN stmt_seq:exp END {: 
				if(modoDepuracion) System.out.println("\t regla bloque_begin");
				/*RESULT = new NodoBloque(exp);*/
				:} 
		;

decl_fun ::= INT ID COMA decl_fun
				{:
					if(modoDepuracion) System.out.println("\t regla INT ID COMA decl_fun");
				:}
			| BOOLEAN ID COMA decl_fun
				{:
					if(modoDepuracion) System.out.println("\t regla BOOLEAN ID COMA decl_fun");
				:}
			| INT ID
				{:
					if(modoDepuracion) System.out.println("\t regla INT ID");
				:}
			| BOOLEAN ID
				{:
					if(modoDepuracion) System.out.println("\t regla BOOLEAN ID");
				:}
			;

funcion_stmt ::= VOID:f_type ID:valor LPAREN decl_fun:decl RPAREN bloque_stmt:exp {:
				if(modoDepuracion) System.out.println("\t regla funcion");
				/*RESULT = new NodoFuncion(f_type,valor,decl,exp);*/
				:}
		| INT:f_type2 ID:valor2 LPAREN decl_fun:decl2 RPAREN bloque_stmt:exp2 {:
				if(modoDepuracion) System.out.println("\t regla funcion");
				RESULT = new NodoFuncion(f_type2,valor2,decl2,exp2);
				:}
		| BOOLEAN:f_type3 ID:valor3 LPAREN decl_fun:decl3 RPAREN bloque_stmt:exp3 {:
				if(modoDepuracion) System.out.println("\t regla funcion");
				RESULT = new NodoFuncion(f_type3,valor3,decl3,exp3);
				:}
		;

param_funcion ::= simple_exp:parametro COMA param_funcion {:
				if(modoDepuracion) System.out.println("\t regla parametros_funcion");
					/*RESULT = new NodoParamFuncion(parametro);*/
				:}
				| simple_exp
					{:
						if(modoDepuracion) System.out.println("\t regla parametros_funcion");
						/*RESULT = new NodoParamFuncion(true);*/
					:}
		;

call_funcion ::= ID:valor LPAREN param_funcion RPAREN 
				{:
					if(modoDepuracion) System.out.println("\t regla llamada_funcion");
					/*RESULT = new NodoCallFuncion(valor.toString(),variables);*/
				:}
				| ID LPAREN RPAREN
					{:
						if(modoDepuracion) System.out.println("\t regla llamada_funcion sin parametros");
						/*RESULT = new NodoCallFuncion(valor.toString(),variables);*/
					:}
		;
