package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}

	public void printModoDepuracion(String message){
		if(modoDepuracion) 
			System.out.println("\t"+message); 
	}
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal FOR;
terminal BOOLEAN;
terminal INT;
terminal BEGIN;
terminal RETURN;
terminal VOID;
terminal NE;
terminal GE;
terminal LE;
terminal COMA;
terminal GT;
terminal LCLASP;
terminal RCLASP;
terminal AND;
terminal OR;
terminal TRUE;
terminal FALSE;

/* Simbolos No Terminales */

non terminal program;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase array_var_access;

non terminal NodoBase decl_var;
non terminal NodoBase var_list;
non terminal NodoBase eq_stmt;
non terminal NodoBase for_stmt;
non terminal NodoBase return_stmt;
non terminal NodoBase funcion_stmt;
non terminal NodoBase bloque_stmt;
non terminal NodoBase decl_fun;
non terminal NodoBase param_funcion;
non terminal NodoBase call_funcion;
non terminal NodoBase logica_exp;

/* Precedencia de operadores */

precedence left OR;
precedence left AND;
precedence left GE;
precedence left GT;
precedence left LE;
precedence left LT;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left OVER;
precedence left LPAREN;
precedence left RPAREN;

/* REGLAS GRAMATICALES */

program		::= 
		stmt_seq:s
			{: 
				printModoDepuracion("regla program");
				ast = s;
			:}
		;
		
decl_var	::= 
		INT var_list:v
			{: 
				printModoDepuracion("\t regla INT decl_var");
				RESULT = new NodoVariable(v,tipoDato.INT);
			:}
		| BOOLEAN var_list:v
			{: 
				printModoDepuracion("\t regla BOOLEAN decl_var");
				RESULT = new NodoVariable(v,tipoDato.BOOLEAN);
			:}
		;
			
var_list	::= 
		ID:variable COMA var_list:v
			{: 
				printModoDepuracion("\t\t regla var_list -> ID COMA"); 
				RESULT = new NodoVariable(variable.toString(), v);
			:}
		| ID:variable
			{: 
				printModoDepuracion("\t\t regla var_list -> ID"); 
				RESULT = new NodoVariable(variable.toString());
			:}
		| ID:variable LCLASP NUM:tam RCLASP COMA var_list:v
			{:
				printModoDepuracion("\t\t regla var_list -> array_declare COMA"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(variable.toString(), tam, v);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla var_list -> array_declare COMA");
				}
			:}
		| ID:variable LCLASP NUM:tam RCLASP
			{:
				printModoDepuracion("\t\t regla var_list -> array_declare"); 
				if(variable!=null && tam!=null){
					RESULT= new NodoArray(variable.toString(), tam);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla var_list -> array_declare COMA");
				}
			:}
		;
			
stmt_seq    ::=
		stmt_seq:ini stmt:sent SEMI 
			{: 
				printModoDepuracion("\t regla stmt_seq -> stmt_seq stmt"); 
				NodoBase hijoActual = ini;
				if(hijoActual !=null){
					while(hijoActual.TieneHermano()){
						hijoActual = hijoActual.getHermanoDerecha();
					}
					hijoActual.setHermanoDerecha(sent);
					RESULT=ini;
				}else{
					RESULT=sent;
				}
			:}
	    | stmt:sent	SEMI
	    	{: 
	    		printModoDepuracion("\t regla stmt_seq -> stmt");
				RESULT=sent;				
			:}
		;

stmt        ::=
		if_stmt:sif
			{: 
				printModoDepuracion("\t\t regla stmt -> if_stmt"); 
				RESULT=sif;
			:}
		| decl_var:dclvar
			{: 
				printModoDepuracion("\t\t regla stmt -> decl_var"); 
				RESULT=dclvar;
			:}	
		| funcion_stmt:declafunc
			{: 
				printModoDepuracion("\t\t regla stmt -> funcion_stmt"); 
				RESULT=declafunc;
			:}
		| bloque_stmt:declablo
			{: 
				printModoDepuracion("\t\t regla stmt -> bloque_stmt"); 
				RESULT=declablo;
			:}
        | repeat_stmt:srep
        	{:
        		printModoDepuracion("\t\t regla stmt -> repeat_stmt"); 
				RESULT=srep;
			:}
		| assign_stmt:sasi
			{: 
				printModoDepuracion("\t\t regla stmt -> assign_stmt"); 
				RESULT=sasi;
			:}
        | read_stmt:slec
        	{: 
        		printModoDepuracion("\t\t regla stmt -> read_stmt");  
				RESULT=slec;
			:}
        | write_stmt:sesc
        	{: 
        		printModoDepuracion("\t\t regla stmt -> write_stmt");
				RESULT=sesc;
			:}
		| for_stmt:sfor 
			{:
				printModoDepuracion("\t\t regla stmt -> for_stmt"); 
				RESULT=sfor;
			:}
		| return_stmt:sretr
			{: 
				printModoDepuracion("\t\t regla stmt -> return_stmt"); 
				RESULT=sretr;
			:} 
		| call_funcion:callfunc_procedure
			{: 
				printModoDepuracion("\t\t regla stmt -> call_funcion by procedure"); 
				RESULT=callfunc_procedure;
			:}
        | error	
        	{: 
        		System.out.println("Ocurrio error en cup regla stmt");
				RESULT=null;
			:}
    	;

if_stmt     ::= 
		IF logica_exp:ex THEN stmt_seq:pthen END 
			{: 
				printModoDepuracion("\t\t\t regla if_stmt -> logica_exp"); 
				RESULT = new NodoIf(ex,pthen);
			:}
		| IF logica_exp:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END
			{: 
				printModoDepuracion("\t\t\t regla if_stmt -> logica_exp else"); 
				RESULT = new NodoIf(ex,pthen,pelse);
			:}
		;

repeat_stmt ::= 
		REPEAT stmt_seq:cuerpo UNTIL exp:prueba	
			{: 
				printModoDepuracion("\t\t\t regla repeat_stmt");
				RESULT = new NodoRepeat(cuerpo,prueba);
			:}
		;

assign_stmt ::= 
		ID:variable ASSIGN exp:ex	
			{: 
				printModoDepuracion("\t\t\t regla assign_stmt -> ID");
				if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_stmt -> ID");
				}
			:}
		| array_var_access:vesc	ASSIGN exp:ex
			{: 
				printModoDepuracion("\t\t\t regla assign_stmt -> array_var_access");
				if(vesc!=null && ex!=null)
					RESULT = new NodoAsignacion(vesc,ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla assign_stmt -> array_var_access");
				}
			:}
		;

read_stmt   ::=
		READ ID:variable
			{: 
				printModoDepuracion("\t\t\t  regla read_stmt -> ID"); 
				if(variable!=null)
					RESULT = new NodoLeer(variable.toString());
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_stmt -> ID");
				}
			:}
		| READ array_var_access:variable
			{: 
				printModoDepuracion("\t\t\t  regla read_stmt -> array_var_access"); 
				if(variable!=null)
					RESULT = new NodoLeer(variable.toString());
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla read_stmt -> array_var_access");
				}
			:}
		;

write_stmt  ::=
		WRITE exp:ex
			{: 
				printModoDepuracion("\t\t\t  regla write_stmt -> exp"); 
				RESULT= new NodoEscribir(ex);
			:}
		;

exp    		::=
		simple_exp:exI GE simple_exp:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> GE");
				RESULT = new NodoOperacion(exI,tipoOp.mayori,exD);
			:} 
		| simple_exp:exI GT simple_exp:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> GT");
				RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
			:}
		 
		| simple_exp:exI LE simple_exp:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> LE");
				RESULT = new NodoOperacion(exI,tipoOp.menori,exD);
			:}
		| simple_exp:exI LT simple_exp:exD	
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> LT");
				RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
			:}
		| simple_exp:exI EQ simple_exp:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> EQ");
				RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
			:} 
		| simple_exp:exI NE simple_exp:exD
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> NE");
				RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
			:}
		| call_funcion:callfunc
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> call_funcion");
				RESULT=callfunc;
			:}
		| simple_exp:ex
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> simple_exp");
				RESULT = ex;
			:}
		| array_var_access:vesc	
			{: 
				printModoDepuracion("\t\t\t\t  regla exp -> array_var_access");
				RESULT=vesc;
			:}
		;

logica_exp ::= 
		exp:exI AND logica_exp:exD
			{: 
				printModoDepuracion("\t\t\t  regla logica_exp -> AND logica_exp");
				RESULT = new NodoLogico(exI,tipoOp.and,exD);			
			:}

		| exp:exI OR logica_exp:exD
			{:
				printModoDepuracion("\t\t\t  regla logica_exp -> OR logica_exp");
				RESULT = new NodoLogico(exI,tipoOp.or,exD);	
			:}
		| exp:exl
			{: 
				printModoDepuracion("\t\t\t  regla logica_exp -> exp");
				RESULT = new NodoLogico(exl);						
			:}
		;

simple_exp  ::=
		simple_exp:exI PLUS term:exD
			{: 
				printModoDepuracion("\t\t\t\t\t  regla simple_exp -> PLUS");
				RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
			:}
		| simple_exp:exI MINUS term:exD
			{: 
				printModoDepuracion("\t\t\t\t\t  regla simple_exp -> MINUS");
				RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
			:}
		| term:ex
			{:
				printModoDepuracion("\t\t\t\t\t  regla simple_exp -> term");
				RESULT=ex;
			:}
		;

term        ::= 
		term:exI TIMES factor:exD
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla term -> TIMES");
				RESULT = new NodoOperacion(exI,tipoOp.por,exD);
			:}
		| term:exI OVER factor:exD
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla term -> OVER");
				RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
			:}
		| factor:ex
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor");
				RESULT=ex;
			:}
		;

factor      ::= 
		LPAREN exp:ex RPAREN	
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> PAREN");
				RESULT = ex;
			:}
		| NUM:valor
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> NUM");
				if(valor!=null){
					RESULT= new NodoValor(valor);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM");
				}
			:}
		| MINUS NUM:valor 
        	{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> NUM NEGATIVO");
				if(valor!=null){
					RESULT= new NodoValor(valor*-1);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> NUM NEGATIVO");
				}
			:}
		| ID:variable
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> ID");
				if(variable!=null){
					//System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
					RESULT= new NodoIdentificador(variable.toString());		
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla factor -> ID");
				}
			:}
		| TRUE   
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> TRUE");
				RESULT= new NodoValor(true);					
			:}
		| FALSE	
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor -> TRUE");
				RESULT= new NodoValor(false);					
			:}
		| error
			{: 
				printModoDepuracion("\t\t\t\t\t\t  regla factor");
				System.out.println("Ocurrio error en cup regla factor");
				RESULT=null;
			:}
		;

array_var_access	::= 
		ID:variable LCLASP simple_exp:pos RCLASP
			{:
				printModoDepuracion("\t\t\t\t  regla array_var_access");
				if(variable!=null && pos!=null){
					RESULT= new NodoArray(variable.toString(), pos);					
				}else{
					RESULT = null;
					System.out.println("Ocurrio error en cup regla array_var_access");
				}
			:}	
		;

eq_stmt 	::= 
		ID:variable EQ exp:ex
			{: 
				//Regla asignacion exclusiva para un for
				printModoDepuracion("\t\t  regla eq_stmt");
				if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 00013");
				}
			:}
		;

for_stmt 	::=
		FOR LPAREN eq_stmt:ini SEMI logica_exp:cond SEMI eq_stmt:inc RPAREN stmt_seq:sent END 
			{: 
				printModoDepuracion("\t  regla for_stmt");
				RESULT = new NodoFor(ini,cond,inc,sent);
			:}
		;

return_stmt ::= 
		RETURN factor:fact
			{: 
				printModoDepuracion("\t\t  regla return_stmt -> factor");
				RESULT = new NodoReturn(fact);
			:}
		| RETURN 
			{: 
				printModoDepuracion("\t\t  regla return_stmt -> empty");
				RESULT = new NodoReturn();
			:};

bloque_stmt  ::= 
		BEGIN stmt_seq:exp END 
			{: 
				printModoDepuracion("regla return_stmt -> bloque_stmt");
				RESULT = new NodoBloque(exp);
			:} 
		;

decl_fun 	::= 
		INT ID COMA decl_fun
			{:
				printModoDepuracion("\t\t regla decl_fun -> INT ID COMA");
			:}
		| BOOLEAN ID COMA decl_fun
			{:
				printModoDepuracion("\t\t regla decl_fun -> BOOLEAN ID COMA");
			:}
		| INT ID
			{:
				printModoDepuracion("\t\t regla decl_fun -> INT ID");

			:}
		| BOOLEAN ID
			{:
				printModoDepuracion("\t\t regla decl_fun -> BOOLEAN ID");
			:}
		;

funcion_stmt ::= 
		VOID:f_type ID:valor LPAREN decl_fun:decl RPAREN bloque_stmt:exp 
			{:
				printModoDepuracion("\t regla funcion_stmt -> VOID decl_fun");
				RESULT = new NodoFuncion(f_type,valor,decl,exp);
			:}
		| INT:f_type2 ID:valor2 LPAREN decl_fun:decl2 RPAREN bloque_stmt:exp2 
			{:
				printModoDepuracion("\t regla funcion_stmt -> INT decl_fun");
				RESULT = new NodoFuncion(f_type2,valor2,decl2,exp2);
			:}
		| BOOLEAN:f_type3 ID:valor3 LPAREN decl_fun:decl3 RPAREN bloque_stmt:exp3
			{:
				printModoDepuracion("\t regla funcion_stmt -> BOOLEAN decl_fun");
				RESULT = new NodoFuncion(f_type3,valor3,decl3,exp3);
			:}
		| VOID:f_type ID:valor LPAREN RPAREN bloque_stmt:exp
			{:
				printModoDepuracion("\t regla funcion_stmt -> VOID");
				RESULT = new NodoFuncion(f_type,valor,exp);
			:}
		| INT:f_type2 ID:valor2 LPAREN RPAREN bloque_stmt:exp2
			{:
				printModoDepuracion("\t regla funcion_stmt -> INT");
				RESULT = new NodoFuncion(f_type2,valor2,exp2);
			:}
		| BOOLEAN:f_type3 ID:valor3 LPAREN RPAREN bloque_stmt:exp3
			{:
				printModoDepuracion("\t regla funcion_stmt -> BOOLEAN");
				RESULT = new NodoFuncion(f_type3,valor3,exp3);
			:}
		;

param_funcion ::= 
		simple_exp:parametro COMA param_funcion
			{:
				printModoDepuracion("\t\t regla param_funcion -> parametro COMA");
				RESULT = new NodoParamFuncion(parametro);
			:}
		| simple_exp:parametro
			{:
				printModoDepuracion("\t\t regla param_funcion -> simple_exp");
				RESULT = new NodoParamFuncion(parametro);
			:}
		;

call_funcion ::= 
		ID:valor LPAREN param_funcion:variables RPAREN 
			{:
				printModoDepuracion("\t\t regla call_funcion -> param_funcion");
				RESULT = new NodoCallFuncion(valor.toString(),variables);
			:}
		| ID:valor LPAREN RPAREN
			{:
				printModoDepuracion("\t\t regla call_funcion -> not param_funcion");
				RESULT = new NodoCallFuncion(valor.toString());
			:}
		;
